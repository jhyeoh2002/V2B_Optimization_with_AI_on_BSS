from scipy.stats import truncnorm
import pandas as pd
import numpy as np

def schedule_batteries(fully_charged_series, n_station, tnum, SOC_thr=0.9, max_stay_duration=24):

    index = fully_charged_series[0]
    available = fully_charged_series[1:]

    N_V_t = []  # Hourly number of required fully charged batteries
    t_a_v = []  # Arrival time of each battery

    N_V_temp = [int(max((available[i] - available[i + 1]),0)) for i in range(len(available) - 1)]
    N_V_temp.insert(0, 0)  # Assuming no arrivals at hour 0
    
    N_V_t += N_V_temp
    n_total = sum(N_V_t) + n_station  #Total battery numbers if each battery is numbered separately
         
    t_a_v.extend([0] * n_station) # the battery that was already there
    for hour, arrivals in enumerate(N_V_t):
        for _ in range(arrivals):
            t_a_v.append(hour)

    # t_d_v: Departure time of each battery (編號越後面越先離開，最大化停留時間 - greedy algorithm)

    """平均分配停留時間：設置一個合理的最大停留時間，每當有需求時，如果有電池的停留時間超過這個值，則優先選擇這些電池。"""
    # t_d_v: Departure time of each battery (Balanced Stay Duration)
    t_d_v = [-1] * n_total
    
    battery_state = [{'id': v, 'arrival': t_a_v[v], 'departure': None} for v in range(n_total)] # 列表包含每个电池的ID、到达时间和离开时间
    
    for hour, demand in enumerate(N_V_t):
        for _ in range(demand):
            # Find batteries that have stayed longer than max_stay_duration
            available_batteries = [b for b in battery_state if b['arrival'] <= hour and (b['departure'] is None) and (hour - b['arrival'] >= max_stay_duration)]
            # If no batteries have stayed longer than max_stay_duration, use all available batteries
            if not available_batteries:
                available_batteries = [b for b in battery_state if b['arrival'] <= hour and (b['departure'] is None)]
            # Sort available batteries by arrival time
            available_batteries.sort(key=lambda x: x['arrival'])
            if available_batteries:
                battery = available_batteries.pop(0)  # Remove the earliest battery to arrive
                battery['departure'] = hour
                if hour>tnum:
                    raise ValueError(f"hour is {hour}, larger than tnum")
        
    t_d_v = [b['departure'] if b['departure'] is not None else tnum for b in sorted(battery_state, key=lambda x: x['id'])]

    # a_vt: Availability of each battery arrives or not
    a_vt = [[0] * tnum for _ in range(n_total)]

    for v in range(n_total):
        for t in range(t_a_v[v], t_d_v[v]):
            a_vt[v][t] = 1

    # SOC_a_v: Arrival state of charge (SOC) for vth e-scooter, generated by truncated normal distribution
    mean1, std1, lower1, upper1 = 45, 5, 0.4, 0.5 # 原本就在的電池，SOC在0.4-0.5之間
    a1, b1 = (lower1 - mean1) / std1, (upper1 - mean1) / std1
    initial_soc = truncnorm(a1, b1, loc=mean1, scale=std1).rvs(n_station)
    
    mean2, std2, lower2, upper2 = 31.5, 2, 0.28, 0.35 # 後來交換的電池，SOC在0.28-0.35之間
    a2, b2 = (lower2 - mean2) / std2, (upper2 - mean2) / std2
    remaining_soc = truncnorm(a2, b2, loc=mean2, scale=std2).rvs(n_total - n_station)
    
    SOC_a_v = list(np.concatenate((initial_soc, remaining_soc)))

    # SOC_d_v: Departure state of charge (SOC) for vth e-scooter
    mean1, std1, lower1, upper1 = 0.45, 0.05, 0.4, 0.5
    a1, b1 = (lower1 - mean1) / std1, (upper1 - mean1) / std1
    truncated_normal_values = truncnorm(a1, b1, loc=mean1, scale=std1).rvs(size=len(t_d_v))
    SOC_d_v = [truncated_normal_values[v] if value == tnum else SOC_thr for v, value in enumerate(t_d_v)]

    return a_vt, SOC_a_v, SOC_d_v