import numpy as np
import pandas as pd
from scipy.stats import truncnorm
import os

c_Batt = 9071 # Battery cost per kilowatt-hour ($/kWh)
pi_Cap = 1.5 # Battery energy capacity (kWh)
pi_CL = 2020 # Battery lifetime in terms of cycle life
pi_DoD = 0.7 # DoD for a certain cycle life
n_station = 38*2 # Number of batteries at the station
SOC_thr = 0.7 # Required leaving SOC

# Choose tnum
# tnum = 2928 # 24 for a day optimization, 168 for a week optimization
tnum = 2928

def generate_escooter_data(tnum = tnum, n_station=n_station, SOC_thr=SOC_thr, max_stay_duration=24):
    
    if os.path.isfile('./Battery_info_withoutdep.csv'):
        print("Battery Info found.")
    # Read data
    else:
        df_demand = pd.read_csv('Full_Data.csv')

        # Choose a day
        df_demand['datetime'] = pd.to_datetime(df_demand['datetime'])
        df_demand = df_demand.set_index('datetime')
        
        # N_V_t: Hourly number of required fully charged batteries
        N_V_t = []
        
        available = df_demand['Available'].tolist()
        N_V_temp = [int(max((available[i] - available[i + 1]),0)) for i in range(len(available) - 1)]
        N_V_temp.append(0) 
        N_V_t += N_V_temp
        print(len(N_V_temp))

        # n_total: Total battery numbers if each battery is numbered separately
        n_total = sum(N_V_t) + n_station

        # t_a_v: Arrival time of each battery
        t_a_v = []
        t_a_v.extend([0] * n_station) # the battery that was already there
        for hour, arrivals in enumerate(N_V_t):
            for _ in range(arrivals):
                t_a_v.append(hour)

        # t_d_v: Departure time of each battery (編號越後面越先離開，最大化停留時間 - greedy algorithm)

        """平均分配停留時間：設置一個合理的最大停留時間，每當有需求時，如果有電池的停留時間超過這個值，則優先選擇這些電池。"""
        # t_d_v: Departure time of each battery (Balanced Stay Duration)
        t_d_v = [-1] * n_total
        battery_state = [{'id': v, 'arrival': t_a_v[v], 'departure': None} for v in range(n_total)] # 列表包含每个电池的ID、到达时间和离开时间
        for hour, demand in enumerate(N_V_t):
            for _ in range(demand):
                # Find batteries that have stayed longer than max_stay_duration
                available_batteries = [b for b in battery_state if b['arrival'] <= hour and (b['departure'] is None) and (hour - b['arrival'] >= max_stay_duration)]
                # If no batteries have stayed longer than max_stay_duration, use all available batteries
                if not available_batteries:
                    available_batteries = [b for b in battery_state if b['arrival'] <= hour and (b['departure'] is None)]
                # Sort available batteries by arrival time
                available_batteries.sort(key=lambda x: x['arrival'])
                if available_batteries:
                    battery = available_batteries.pop(0)  # Remove the earliest battery to arrive
                    battery['departure'] = hour
                    if hour>tnum:
                        raise ValueError(f"hour is {hour}, larger than tnum")
            
        t_d_v = [b['departure'] if b['departure'] is not None else tnum for b in sorted(battery_state, key=lambda x: x['id'])]

        # a_vt: Availability of each battery arrives or not
        a_vt = [[0] * tnum for _ in range(n_total)]

        for v in range(n_total):
            for t in range(t_a_v[v], t_d_v[v]):
                a_vt[v][t] = 1

        # SOC_a_v: Arrival state of charge (SOC) for vth e-scooter, generated by truncated normal distribution
        mean1, std1, lower1, upper1 = 45, 5, 0.4, 0.5 # 原本就在的電池，SOC在0.4-0.5之間
        a1, b1 = (lower1 - mean1) / std1, (upper1 - mean1) / std1
        initial_soc = truncnorm(a1, b1, loc=mean1, scale=std1).rvs(n_station)
        mean2, std2, lower2, upper2 = 31.5, 2, 0.28, 0.35 # 後來交換的電池，SOC在0.28-0.35之間
        a2, b2 = (lower2 - mean2) / std2, (upper2 - mean2) / std2
        remaining_soc = truncnorm(a2, b2, loc=mean2, scale=std2).rvs(n_total - n_station)
        SOC_a_v = list(np.concatenate((initial_soc, remaining_soc)))

        # SOC_d_v: Departure state of charge (SOC) for vth e-scooter
        mean1, std1, lower1, upper1 = 0.45, 0.05, 0.4, 0.5
        a1, b1 = (lower1 - mean1) / std1, (upper1 - mean1) / std1
        truncated_normal_values = truncnorm(a1, b1, loc=mean1, scale=std1).rvs(size=len(t_d_v))
        SOC_d_v = [truncated_normal_values[v] if value == tnum else SOC_thr for v, value in enumerate(t_d_v)]

        battery_info = pd.DataFrame({
            "ID": list(range(1, len(t_a_v)+1)),
            "Arrival_hour":t_a_v,
            "Arrival_SOC":SOC_a_v,

        })

        battery_info.to_csv('./Battery_info_withoutdep.csv',index=False)
        
        # battery_info = pd.DataFrame({
        #     "ID": list(range(1, len(t_a_v)+1)),
        #     "Arrival_hour":t_a_v,
        #     "Departure_hour":t_d_v,
        #     "Arrival_SOC":SOC_a_v,
        #     "Departure_SOC":SOC_d_v ,
        #     "Availability":a_vt
        # })

        # battery_info.to_csv('./Battery_info.csv',index=False)